#!/usr/bin/env python3
"""
FlxOS hardware topology scaffold generator.

Generates per-profile C++ init skeletons from `Profiles/<id>/profile.yaml`
by deriving bus/peripheral topology from profile hardware metadata.

Usage examples:
    python Buildscripts/hwgen.py --profile cyd-2432s028r
    python Buildscripts/hwgen.py --all
    python Buildscripts/hwgen.py --profile cyd-2432s028r --stdout
"""

from __future__ import annotations

import argparse
import re
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Optional


ROOT_DIR = Path(__file__).resolve().parent.parent
PROFILES_DIR = ROOT_DIR / "Profiles"
SDKCONFIG_DEFAULTS = ROOT_DIR / "sdkconfig.defaults"
SDKCONFIG_FILE = ROOT_DIR / "sdkconfig"

GENERATED_SIGNATURE = "Generated by Buildscripts/hwgen.py"


def parse_yaml(filepath: Path) -> dict:
    """Parse a simple YAML file into a nested dict."""
    result: dict[str, Any] = {}
    stack: list[tuple[Any, int]] = [(result, -1)]  # (container, indent_level)

    with filepath.open(encoding="utf-8") as f:
        for line in f:
            stripped = line.strip()
            if not stripped or stripped.startswith("#"):
                continue

            indent = len(line) - len(line.lstrip())
            while len(stack) > 1 and stack[-1][1] >= indent:
                stack.pop()

            current = stack[-1][0]

            # Array item
            if stripped.startswith("- "):
                val: Any = stripped[2:].strip().strip('"').strip("'")
                if isinstance(val, str):
                    if val.lower() in ("true", "yes"):
                        val = True
                    elif val.lower() in ("false", "no"):
                        val = False

                if isinstance(current, list):
                    current.append(val)
                elif isinstance(current, dict):
                    parent_container, _ = stack[-2] if len(stack) > 1 else (result, -1)
                    if isinstance(parent_container, dict):
                        for key, value in parent_container.items():
                            if value is current:
                                parent_container[key] = [val]
                                stack[-1] = (parent_container[key], stack[-1][1])
                                break
                continue

            # Key: value
            match = re.match(r"^([a-zA-Z0-9_-]+):\s*(.*)$", stripped)
            if not match:
                raise ValueError(f"Invalid YAML line in {filepath}: {line.rstrip()}")

            key = match.group(1).replace("-", "_")
            val = match.group(2).strip()

            val = re.sub(r"\s+#.*$", "", val)
            val = val.strip('"').strip("'")

            if val == "" or val is None:
                nested: dict[str, Any] = {}
                if not isinstance(current, dict):
                    raise ValueError(f"Invalid mapping parent in {filepath}: {line.rstrip()}")
                current[key] = nested
                stack.append((nested, indent))
            elif val.startswith("[") and val.endswith("]"):
                items = [x.strip().strip('"').strip("'") for x in val[1:-1].split(",") if x.strip()]
                if not isinstance(current, dict):
                    raise ValueError(f"Invalid mapping parent in {filepath}: {line.rstrip()}")
                current[key] = items
            else:
                if val.lower() in ("true", "yes"):
                    scalar: Any = True
                elif val.lower() in ("false", "no"):
                    scalar = False
                elif val.lower() == "null":
                    scalar = None
                else:
                    try:
                        scalar = int(val)
                    except ValueError:
                        try:
                            scalar = float(val)
                        except ValueError:
                            scalar = val

                if not isinstance(current, dict):
                    raise ValueError(f"Invalid mapping parent in {filepath}: {line.rstrip()}")
                current[key] = scalar

    return result


def get_nested(data: dict[str, Any], path: str, default: Any = None) -> Any:
    """Return nested dict value using dot path."""
    current: Any = data
    for key in path.split("."):
        if isinstance(current, dict) and key in current:
            current = current[key]
        else:
            return default
    return current


def _deep_merge(base: Any, override: Any) -> Any:
    """Recursively merge dictionaries with override precedence."""
    if isinstance(base, dict) and isinstance(override, dict):
        merged: dict[str, Any] = {}
        for key in base.keys() | override.keys():
            if key in base and key in override:
                merged[key] = _deep_merge(base[key], override[key])
            elif key in override:
                merged[key] = override[key]
            else:
                merged[key] = base[key]
        return merged
    return override


def _resolve_inherits_path(inherits: str, profile_dir: Path) -> Path:
    ref = inherits.strip()
    if not ref:
        raise ValueError("inherits cannot be empty")
    if not ref.endswith(".yaml"):
        ref = f"{ref}.yaml"
    candidate = Path(ref)
    if candidate.is_absolute():
        return candidate
    # Prefer Profiles/ root, then profile-local for flexibility.
    root_relative = (PROFILES_DIR / candidate).resolve()
    if root_relative.exists():
        return root_relative
    return (profile_dir / candidate).resolve()


def _load_profile_yaml_with_inheritance(
    profile_yaml: Path, visited: Optional[set[Path]] = None
) -> dict[str, Any]:
    if visited is None:
        visited = set()

    resolved_path = profile_yaml.resolve()
    if resolved_path in visited:
        raise ValueError(f"Inheritance cycle detected at {resolved_path}")
    visited.add(resolved_path)

    data = parse_yaml(profile_yaml)
    inherits = data.get("inherits")
    if inherits is None or str(inherits).lower() in ("", "null", "~"):
        visited.remove(resolved_path)
        return data

    base_yaml = _resolve_inherits_path(str(inherits), profile_yaml.parent)
    if not base_yaml.exists():
        raise ValueError(f"inherits path not found: {inherits} ({base_yaml})")

    base_data = _load_profile_yaml_with_inheritance(base_yaml, visited)
    visited.remove(resolved_path)
    return _deep_merge(base_data, data)


def get_current_profile() -> Optional[str]:
    """Read currently selected profile from sdkconfig files."""
    pattern = re.compile(r'^CONFIG_FLXOS_PROFILE="(.+)"')
    for path in (SDKCONFIG_DEFAULTS, SDKCONFIG_FILE):
        if not path.exists():
            continue
        with path.open(encoding="utf-8") as f:
            for line in f:
                match = pattern.match(line.strip())
                if match:
                    return match.group(1)
    return None


def discover_profile_ids() -> list[str]:
    """Discover all profile IDs by scanning Profiles/*/profile.yaml."""
    profile_ids: list[str] = []
    if not PROFILES_DIR.exists():
        return profile_ids

    for entry in sorted(PROFILES_DIR.iterdir()):
        if not entry.is_dir() or entry.name.startswith("_"):
            continue
        if (entry / "profile.yaml").exists():
            profile_ids.append(entry.name)
    return profile_ids


def _sanitize_namespace(profile_id: str) -> str:
    text = re.sub(r"[^a-zA-Z0-9_]", "_", profile_id)
    if not text:
        return "profile"
    if text[0].isdigit():
        text = f"_{text}"
    return text


def _cxx_quote(value: Any) -> str:
    text = str(value)
    text = text.replace("\\", "\\\\").replace('"', '\\"')
    return f"\"{text}\""


def _format_scalar(value: Any) -> str:
    if value is None:
        return "null"
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, list):
        return "[" + ", ".join(_format_scalar(v) for v in value) + "]"
    return str(value)


def _flatten_mapping(data: Any, prefix: str = "") -> list[tuple[str, Any]]:
    if isinstance(data, dict):
        rows: list[tuple[str, Any]] = []
        for key in sorted(data.keys()):
            child_prefix = f"{prefix}.{key}" if prefix else key
            rows.extend(_flatten_mapping(data[key], child_prefix))
        return rows
    return [(prefix, data)]


def _as_dict(value: Any) -> dict[str, Any]:
    return value if isinstance(value, dict) else {}


def _is_disabled_pin(value: Any) -> bool:
    if value is None:
        return True
    text = str(value).strip().lower()
    return text in ("", "-1", "null", "~")


def _filter_pins(pins: dict[str, Any], keys: tuple[str, ...]) -> dict[str, Any]:
    filtered: dict[str, Any] = {}
    for key in keys:
        if key in pins and not _is_disabled_pin(pins[key]):
            filtered[key] = pins[key]
    return filtered


def _spi_host_literal(value: Any, default: int = 2) -> str:
    if isinstance(value, str):
        text = value.strip()
        if re.fullmatch(r"SPI[0-9]+_HOST", text, flags=re.IGNORECASE):
            return text.upper()
        if text.lower() in ("", "null", "~", "shared"):
            return f"SPI{default}_HOST"
        try:
            num = int(text)
        except ValueError:
            return text
        return f"SPI{num if num >= 0 else default}_HOST"

    if value is None:
        return f"SPI{default}_HOST"
    if isinstance(value, (int, float)):
        num = int(value)
        return f"SPI{num if num >= 0 else default}_HOST"
    return str(value)


def _spi_host_number(host_literal: str) -> Optional[int]:
    match = re.fullmatch(r"SPI([0-9]+)_HOST", host_literal, flags=re.IGNORECASE)
    if not match:
        return None
    return int(match.group(1))


def _spi_bus_name(host_literal: str, fallback: str) -> str:
    host_num = _spi_host_number(host_literal)
    if host_num is not None:
        return f"spi{host_num}"
    sanitized = re.sub(r"[^a-z0-9]+", "_", host_literal.lower()).strip("_")
    if sanitized:
        return f"spi_{sanitized}"
    return fallback


def _unique_bus_name(base_name: str, buses: dict[str, Any]) -> str:
    if base_name not in buses:
        return base_name
    idx = 2
    while True:
        candidate = f"{base_name}_{idx}"
        if candidate not in buses:
            return candidate
        idx += 1


def _compact_dict(data: dict[str, Any]) -> dict[str, Any]:
    compact: dict[str, Any] = {}
    for key, value in data.items():
        if value is None:
            continue
        if isinstance(value, dict):
            child = _compact_dict(value)
            if child:
                compact[key] = child
        else:
            compact[key] = value
    return compact


def derive_topology_from_profile(profile: dict[str, Any]) -> dict[str, Any]:
    """Derive HWD-like topology from merged profile metadata."""
    topology: dict[str, Any] = {"version": 1, "buses": {}, "peripherals": {}}
    buses = topology["buses"]
    peripherals = topology["peripherals"]

    hardware = _as_dict(profile.get("hardware"))
    display = _as_dict(hardware.get("display"))
    touch = _as_dict(hardware.get("touch"))
    sdcard = _as_dict(hardware.get("sdcard"))
    cli = _as_dict(profile.get("cli"))
    console = _as_dict(profile.get("console"))

    display_bus_name: Optional[str] = None
    display_host_literal: Optional[str] = None
    display_host_num: Optional[int] = None

    if bool(display.get("enabled")) and str(display.get("bus", "spi")).lower() == "spi":
        display_spi = _as_dict(display.get("spi"))
        display_host_literal = _spi_host_literal(display_spi.get("host", 2), default=2)
        display_host_num = _spi_host_number(display_host_literal)
        display_bus_name = _spi_bus_name(display_host_literal, "spi2")

        display_bus_cfg = _compact_dict(
            {
                "type": "spi",
                "host": display_host_literal,
                "mode": display_spi.get("mode"),
                "write_freq_hz": display_spi.get("freq_write"),
                "read_freq_hz": display_spi.get("freq_read"),
                "dma_channel": display_spi.get("dma_channel"),
                "shared": bool(get_nested(display, "panel.bus_shared", False)),
                "pins": _filter_pins(_as_dict(display.get("pins")), ("mosi", "miso", "sclk")),
            }
        )
        buses[display_bus_name] = display_bus_cfg

        display_peripheral = _compact_dict(
            {
                "type": "display",
                "driver": display.get("driver"),
                "bus": display_bus_name,
                "pins": _filter_pins(_as_dict(display.get("pins")), ("cs", "dc", "rst", "busy", "bckl")),
                "panel": {
                    "width": display.get("width"),
                    "height": display.get("height"),
                    "rotation": display.get("rotation"),
                    "color_depth": display.get("color_depth"),
                },
            }
        )
        peripherals["display"] = display_peripheral

    if bool(touch.get("enabled")) and str(touch.get("bus", "spi")).lower() == "spi":
        touch_spi = _as_dict(touch.get("spi"))
        touch_host_raw = touch_spi.get("host", -1)
        touch_host_literal = _spi_host_literal(touch_host_raw, default=display_host_num or 2)
        touch_host_num = _spi_host_number(touch_host_literal)

        touch_bus_shared = bool(touch_spi.get("bus_shared", False))
        touch_separate_pins = bool(touch_spi.get("separate_pins", False))

        same_host_as_display = (
            display_host_literal is not None
            and touch_host_literal == display_host_literal
        ) or (touch_host_num is None and display_host_literal is not None)

        share_display_bus = bool(
            display_bus_name
            and touch_bus_shared
            and not touch_separate_pins
            and (same_host_as_display or _is_disabled_pin(touch_host_raw))
        )

        touch_bus_name: str
        if share_display_bus and display_bus_name:
            touch_bus_name = display_bus_name
        else:
            preferred = "spi_touch" if touch_separate_pins else _spi_bus_name(touch_host_literal, "spi_touch")
            touch_bus_name = preferred if preferred not in buses else _unique_bus_name(preferred, buses)
            touch_bus_cfg = _compact_dict(
                {
                    "type": "spi",
                    "host": touch_host_literal,
                    "mode": touch_spi.get("mode", 0),
                    "freq_hz": touch_spi.get("freq"),
                    "shared_with": display_bus_name if touch_bus_shared and display_bus_name else None,
                    "pins": _filter_pins(_as_dict(touch.get("pins")), ("mosi", "miso", "sclk")),
                }
            )
            buses[touch_bus_name] = touch_bus_cfg

        touch_peripheral = _compact_dict(
            {
                "type": "touch",
                "driver": touch.get("driver"),
                "bus": touch_bus_name,
                "pins": _filter_pins(_as_dict(touch.get("pins")), ("cs", "int")),
                "calibration": {
                    "x_min": get_nested(touch, "calibration.x_min"),
                    "x_max": get_nested(touch, "calibration.x_max"),
                    "y_min": get_nested(touch, "calibration.y_min"),
                    "y_max": get_nested(touch, "calibration.y_max"),
                    "offset_rotation": get_nested(touch, "calibration.offset_rotation"),
                },
            }
        )
        peripherals["touch"] = touch_peripheral

    if bool(sdcard.get("enabled")):
        sd_spi_host_raw = sdcard.get("spi_host")
        sd_pins = _filter_pins(_as_dict(sdcard.get("pins")), ("mosi", "miso", "sclk"))
        sd_host_literal = _spi_host_literal(sd_spi_host_raw, default=display_host_num or 2)
        sd_host_num = _spi_host_number(sd_host_literal)

        share_display_bus = bool(
            display_bus_name
            and (
                str(sd_spi_host_raw).strip().lower() == "shared"
                or (
                    display_host_num is not None
                    and sd_host_num is not None
                    and display_host_num == sd_host_num
                    and not sd_pins
                )
            )
        )

        if share_display_bus and display_bus_name:
            sd_bus_name = display_bus_name
        else:
            preferred = _spi_bus_name(sd_host_literal, "spi_sdcard")
            if display_bus_name and preferred == display_bus_name:
                preferred = f"{preferred}_sdcard"
            sd_bus_name = preferred if preferred not in buses else _unique_bus_name(preferred, buses)
            sd_bus_cfg = _compact_dict(
                {
                    "type": "spi",
                    "host": sd_host_literal,
                    "freq_khz": sdcard.get("max_freq_khz"),
                    "pins": sd_pins,
                }
            )
            buses[sd_bus_name] = sd_bus_cfg

        sd_peripheral = _compact_dict(
            {
                "type": "sdcard",
                "bus": sd_bus_name,
                "pins": _filter_pins(_as_dict(sdcard.get("pins")), ("cs",)),
                "max_freq_khz": sdcard.get("max_freq_khz"),
            }
        )
        peripherals["sdcard"] = sd_peripheral

    if bool(cli.get("enabled")):
        if bool(console.get("usb_serial_jtag", False)):
            cli_bus_name = "usb_serial_jtag0"
            buses.setdefault(
                cli_bus_name,
                {"type": "usb_serial_jtag", "port": "USB_SERIAL_JTAG"},
            )
        else:
            cli_bus_name = "uart0"
            buses.setdefault(
                cli_bus_name,
                {"type": "uart", "port": "UART_NUM_0", "baudrate": 115200},
            )

        cli_peripheral = _compact_dict(
            {
                "type": "cli",
                "bus": cli_bus_name,
                "prompt": cli.get("prompt"),
            }
        )
        peripherals.setdefault("cli_console", cli_peripheral)

    return topology


def validate_hardware_doc(profile_id: str, hw: dict) -> list[str]:
    """Validate basic HWD topology constraints."""
    errors: list[str] = []

    if not isinstance(hw, dict):
        return ["Derived topology must be a mapping"]

    buses = hw.get("buses", {})
    if not isinstance(buses, dict):
        errors.append("buses must be a mapping")
        buses = {}

    peripherals = hw.get("peripherals", {})
    if not isinstance(peripherals, dict):
        errors.append("peripherals must be a mapping")
        peripherals = {}

    for bus_name, bus_cfg in buses.items():
        if not isinstance(bus_cfg, dict):
            errors.append(f"buses.{bus_name} must be a mapping")
            continue
        bus_type = bus_cfg.get("type")
        if not isinstance(bus_type, str) or not bus_type.strip():
            errors.append(f"buses.{bus_name}.type must be a non-empty string")
            continue
        lowered = bus_type.lower()
        if lowered == "spi" and "host" not in bus_cfg:
            errors.append(f"buses.{bus_name}: SPI bus requires 'host'")
        if lowered == "i2c" and "port" not in bus_cfg:
            errors.append(f"buses.{bus_name}: I2C bus requires 'port'")

    for per_name, per_cfg in peripherals.items():
        if not isinstance(per_cfg, dict):
            errors.append(f"peripherals.{per_name} must be a mapping")
            continue
        per_type = per_cfg.get("type")
        if not isinstance(per_type, str) or not per_type.strip():
            errors.append(f"peripherals.{per_name}.type must be a non-empty string")
        bus_ref = per_cfg.get("bus")
        if bus_ref is not None:
            bus_key = str(bus_ref)
            if bus_key not in buses:
                errors.append(f"peripherals.{per_name}.bus references unknown bus '{bus_key}'")

    if not buses and not peripherals:
        errors.append(f"{profile_id}: derived topology has no buses or peripherals")

    return errors


def _extract_controller(bus_cfg: dict[str, Any]) -> str:
    for key in ("host", "port", "controller", "channel", "spi_host"):
        if key in bus_cfg and bus_cfg[key] is not None:
            return str(bus_cfg[key])
    return "n/a"


def render_cpp(profile_id: str, source_ref: str, hw: dict[str, Any]) -> str:
    """Render generated C++ scaffold from hardware topology."""
    namespace_id = _sanitize_namespace(profile_id)
    generated_on = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    buses_raw = hw.get("buses", {})
    peripherals_raw = hw.get("peripherals", {})
    buses = buses_raw if isinstance(buses_raw, dict) else {}
    peripherals = peripherals_raw if isinstance(peripherals_raw, dict) else {}

    bus_rows = []
    for bus_name in sorted(buses.keys()):
        cfg = buses[bus_name] if isinstance(buses[bus_name], dict) else {}
        bus_rows.append(
            {
                "name": str(bus_name),
                "type": str(cfg.get("type", "unknown")),
                "controller": _extract_controller(cfg),
            }
        )

    peripheral_rows = []
    for per_name in sorted(peripherals.keys()):
        cfg = peripherals[per_name] if isinstance(peripherals[per_name], dict) else {}
        peripheral_rows.append(
            {
                "name": str(per_name),
                "type": str(cfg.get("type", "unknown")),
                "bus": str(cfg.get("bus", "")),
            }
        )

    lines: list[str] = [
        f"// {GENERATED_SIGNATURE}",
        f"// Profile: {profile_id}",
        f"// Source: {source_ref}",
        f"// Generated: {generated_on}",
        "//",
        "// This file is an initialization scaffold. Fill in TODO blocks with",
        "// concrete driver creation and registration for the profile.",
        "",
        "#include <array>",
        "#include <esp_err.h>",
        "#include <esp_log.h>",
        "",
        f"namespace flx::profile::{namespace_id}::hwd {{",
        "",
        "namespace {",
        f'constexpr const char* TAG = "hwd:{profile_id}";',
        "",
        "struct BusDescriptor {",
        "    const char* name;",
        "    const char* type;",
        "    const char* controller;",
        "};",
        "",
        "struct PeripheralDescriptor {",
        "    const char* name;",
        "    const char* type;",
        "    const char* bus;",
        "};",
        "",
        f"constexpr std::array<BusDescriptor, {len(bus_rows)}> kBuses = {{{{",
    ]

    for row in bus_rows:
        lines.append(
            f"    BusDescriptor{{{_cxx_quote(row['name'])}, {_cxx_quote(row['type'])}, {_cxx_quote(row['controller'])}}},"
        )

    lines.extend(
        [
            "}};",
            "",
            f"constexpr std::array<PeripheralDescriptor, {len(peripheral_rows)}> kPeripherals = {{{{",
        ]
    )

    for row in peripheral_rows:
        lines.append(
            f"    PeripheralDescriptor{{{_cxx_quote(row['name'])}, {_cxx_quote(row['type'])}, {_cxx_quote(row['bus'])}}},"
        )

    lines.extend(
        [
            "}};",
            "}  // namespace",
            "",
            "void initBuses() {",
            '    ESP_LOGI(TAG, "HWD buses: %u", static_cast<unsigned>(kBuses.size()));',
            "    for (const auto& bus : kBuses) {",
            '        ESP_LOGI(TAG, "bus=%s type=%s controller=%s", bus.name, bus.type, bus.controller);',
            "        // TODO: Configure and initialize this bus.",
            "    }",
            "",
            "    // Bus topology derived from profile metadata:",
        ]
    )

    if buses:
        for bus_name in sorted(buses.keys()):
            bus_cfg = buses[bus_name] if isinstance(buses[bus_name], dict) else {}
            flattened = _flatten_mapping(bus_cfg)
            detail = ", ".join(f"{k}={_format_scalar(v)}" for k, v in flattened) if flattened else "no fields"
            lines.append(f"    // - {bus_name}: {detail}")
    else:
        lines.append("    // - (none)")

    lines.extend(
        [
            "}",
            "",
            "void initPeripherals() {",
            '    ESP_LOGI(TAG, "HWD peripherals: %u", static_cast<unsigned>(kPeripherals.size()));',
            "    for (const auto& peripheral : kPeripherals) {",
            '        ESP_LOGI(TAG, "peripheral=%s type=%s bus=%s", peripheral.name, peripheral.type, peripheral.bus);',
            "        // TODO: Instantiate and wire this peripheral.",
            "    }",
            "",
            "    // Peripheral topology derived from profile metadata:",
        ]
    )

    if peripherals:
        for per_name in sorted(peripherals.keys()):
            per_cfg = peripherals[per_name] if isinstance(peripherals[per_name], dict) else {}
            flattened = _flatten_mapping(per_cfg)
            detail = ", ".join(f"{k}={_format_scalar(v)}" for k, v in flattened) if flattened else "no fields"
            lines.append(f"    // - {per_name}: {detail}")
    else:
        lines.append("    // - (none)")

    lines.extend(
        [
            "}",
            "",
            "void initHardware() {",
            "    initBuses();",
            "    initPeripherals();",
            "}",
            "",
            f"}}  // namespace flx::profile::{namespace_id}::hwd",
            "",
            'extern "C" esp_err_t flx_profile_hwd_init() {',
            f"    flx::profile::{namespace_id}::hwd::initHardware();",
            "    return ESP_OK;",
            "}",
            "",
        ]
    )
    return "\n".join(lines)


def write_generated_file(path: Path, content: str, force: bool) -> None:
    """Write generated output with overwrite guard for manual files."""
    if path.exists():
        existing = path.read_text(encoding="utf-8", errors="ignore")
        if GENERATED_SIGNATURE not in existing and not force:
            raise RuntimeError(
                f"Refusing to overwrite non-generated file: {path}. "
                "Use --force to overwrite."
            )

    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")


def generate_for_profile(profile_id: str, output_override: Optional[str], stdout: bool, force: bool) -> int:
    """Generate scaffold for one profile."""
    profile_dir = PROFILES_DIR / profile_id
    profile_yaml = profile_dir / "profile.yaml"
    if not profile_yaml.exists():
        print(f"error: profile '{profile_id}' not found at {profile_yaml}", file=sys.stderr)
        return 1

    try:
        profile_data_raw = parse_yaml(profile_yaml)
        profile_data = _load_profile_yaml_with_inheritance(profile_yaml)
    except Exception as exc:
        print(f"error: failed to load {profile_yaml}: {exc}", file=sys.stderr)
        return 1

    if "hwd" in profile_data_raw:
        print(
            f"error: legacy 'hwd' section is not supported in {profile_yaml}. "
            "Use profile hardware fields only.",
            file=sys.stderr,
        )
        return 1

    topology = derive_topology_from_profile(profile_data)
    errors = validate_hardware_doc(profile_id, topology)
    if errors:
        print(f"error: invalid hardware topology for '{profile_id}':", file=sys.stderr)
        for err in errors:
            print(f"  - {err}", file=sys.stderr)
        return 1

    source_ref = f"{profile_yaml.relative_to(ROOT_DIR).as_posix()} (derived)"
    generated_cpp = render_cpp(profile_id, source_ref, topology)
    if stdout:
        print(generated_cpp)
        return 0

    if output_override:
        output_path = Path(output_override).expanduser()
        if not output_path.is_absolute():
            output_path = ROOT_DIR / output_path
    else:
        output_path = profile_dir / "Source" / "hwd" / "GeneratedInit.cpp"

    try:
        write_generated_file(output_path, generated_cpp, force=force)
    except Exception as exc:
        print(f"error: failed to write {output_path}: {exc}", file=sys.stderr)
        return 1

    relative_out = output_path.relative_to(ROOT_DIR).as_posix()
    print(f"generated: {relative_out}")
    return 0


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Generate HWD C++ init scaffold from Profiles/<id>/profile.yaml"
    )
    parser.add_argument("profile_id", nargs="?", default=None, help="Profile ID (optional positional form)")
    parser.add_argument("--profile", dest="profile_opt", default=None, help="Profile ID")
    parser.add_argument("--all", action="store_true", help="Generate scaffold for all profiles")
    parser.add_argument("--stdout", action="store_true", help="Print generated C++ to stdout")
    parser.add_argument("--output", default=None, help="Output path (single profile only)")
    parser.add_argument("--force", action="store_true", help="Overwrite non-generated file")
    args = parser.parse_args()

    selected_profile = args.profile_opt or args.profile_id
    if args.profile_opt and args.profile_id and args.profile_opt != args.profile_id:
        print("error: positional profile_id and --profile disagree", file=sys.stderr)
        return 1

    if args.all and selected_profile:
        print("error: --all cannot be combined with an explicit profile", file=sys.stderr)
        return 1

    if args.all and args.output:
        print("error: --output is only supported for single-profile generation", file=sys.stderr)
        return 1

    if args.all and args.stdout:
        print("error: --stdout is only supported for single-profile generation", file=sys.stderr)
        return 1

    if args.all:
        profile_ids = discover_profile_ids()
        if not profile_ids:
            print(f"error: no profiles found in {PROFILES_DIR}", file=sys.stderr)
            return 1

        generated = 0
        failures = 0

        for profile_id in profile_ids:
            result = generate_for_profile(profile_id, output_override=None, stdout=False, force=args.force)
            if result == 0:
                generated += 1
            else:
                failures += 1

        print(f"summary: generated={generated}, failures={failures}")
        return 1 if failures else 0

    if selected_profile is None:
        selected_profile = get_current_profile()
        if selected_profile is None:
            print("error: no profile specified and no selected profile found", file=sys.stderr)
            return 1

    return generate_for_profile(
        selected_profile,
        output_override=args.output,
        stdout=args.stdout,
        force=args.force,
    )


if __name__ == "__main__":
    sys.exit(main())
